> [!NOTE]
> The syntax highlighting in this document is uhh... weird. Sadly, GitHub does not
> support syntax-highlighted diff blocks. Maybe I'll find a better alternative to
> this in the future.

# How to use React-Plug

This is not exactly a follow-along tutorial, but it offers a reasonably detailed
look at React-Plug's concepts. If you want to check out what a plugin using it looks
like, try the [example](example) plugin. It's assumed that you already know the
basics of nih-plug going into this.

> [!WARNING]
> The API of React-Plug is still very unstable. Some of these code snippets might
> end up being outdated.

<!-- TOC -->

* [How to use React-Plug](#how-to-use-react-plug)
    * [ğŸ”Œ Plugin](#-plugin)
        * [ğŸšï¸Parameters](#parameters)
        * [ğŸ’¬ Messages](#-messages)
        * [ğŸ›ï¸ Editor](#-editor)
    * [ğŸ–Œï¸ GUI](#-gui)
        * [ğŸšï¸ Parameters](#-parameters)
        * [ğŸ’¬ Messages](#-messages-1)
    * [ğŸ¬ Fin~](#-fin)

<!-- TOC -->

We'll start by running `cargo generate gh:exa04/react-plug-template` to create a new
project.

## ğŸ”Œ Plugin

The main plugin code is inside the `src/` directory. Let's see what we can do with
the generated code.

### ğŸšï¸Parameters

The parameters of a React-Plug plugin are declared using a super simple macro that
takes care of a lot of the boilerplate that would usually come with a WebView
plugin. You can define your parameters once using a domain specific language - the
`rp-params!` macro then handles all the fluff.

Let's add a `muted` parameter to what we just generated.

*src/params.rs*

```diff
    rp_params! {
        ExampleParams {
            gain: FloatParam {
                name: "Gain",
                value: util::db_to_gain(0.0),
                range: FloatRange::Skewed {
                    min: util::db_to_gain(-30.0),
                    max: util::db_to_gain(30.0),
                    factor: FloatRange::gain_skew_factor(-30.0, 30.0),
                },
                smoother: SmoothingStyle::Logarithmic(50.0),
                unit: " dB",
                value_to_string: formatters::v2s_f32_gain_to_db(2),
                string_to_value: formatters::s2v_f32_gain_to_db(),
            },
+           muted: BoolParam {
+               name: "Muted",
+               value: false
+           },
        }
    }
```

You can see that the parameters are declared along with their types, default values,
and more properties, such as the range, smoother, and formatters. You can specify as
many parameters as you like, as long as you include the necessary information, such
as names, values, and so on.

<details>
  <summary>Why exactly is this needed?</summary>

The [message](#-messages) enums also communicate parameter changes. For this to
work:

- It needs to be known what parameters exist and what plain data types they store
- Units, smoothing styles, formatters need to be sent to the GUI
- Parameter changes need to be serialized as JSON
- Parameters need to have a callback attached to them in order to send messages to
  the GUI when their values change
- TS Bindings for all parameter types need to exist.

You _could_ explicitly define all these things. The amount of boilerplate would be
really annoying, though. This is why this macro derives traits, defined the
parameter types, and attaches the aforementioned callbacks.

> As practical as this is, one downside of it is that the `new` function of your
> parameters will be generated by React-Plug. I'd love for there to be a more
> flexible solution. If any macro magician wants to help me out with this, file a
> pull request, create an issue, or cast a spell on my codebase ğŸ§™
</details>

We can now use the `muted` parameter in our plugin code. Let's add a simple check
that mutes the output if the parameter is set to `true`.

*src/lib.rs*

```diff
    fn process(
        &mut self,
        buffer: &mut Buffer,
        _aux: &mut AuxiliaryBuffers,
        _context: &mut impl ProcessContext<Self>,
    ) -> ProcessStatus {
        for channel_samples in buffer.iter_samples() {

+           if self.params.muted.value() {
+               for sample in channel_samples {
+                   *sample = 0.0;
+               }
+               continue;
+           }
    
            let gain = self.params.gain.smoothed.next();
            for sample in channel_samples {
                *sample *= gain;
            }
        }
    
        ProcessStatus::Normal
    }
```

### ğŸ’¬ Messages

For data that isn't just parameter updates, we'll want to send our own custom
**messages**. These messages are simply enum variants which get serialized as JSON
and sent to the WebView hosting the GUI. You can specify your own message types by
deriving the `GuiMessage` and `PluginMessage` traits. Some internal messages are
then added automatically.

Let's add a `Ping` message that the GUI can send to the plugin, and a `Pong` message
that the plugin can send back.

*src/lib.rs*

```diff
    #[gui_message(params = ExampleParams)]
    pub enum GuiMessage {
+       Ping,
    }
    
    #[plugin_message(params = ExampleParams)]
    pub enum PluginMessage {
+       Pong,
    }
```

We'll handle the `Ping` by responding with a `Pong`. To do this, let's go over to
the editor function and add a message handler for the `Ping` message.

### ğŸ›ï¸ Editor

Inside the `editor` function, the plugin defines its editor. This is where you can
set up your GUI. The `ReactPlugEditor` struct is used to create a new editor.

To handle incoming `Ping` messages, we can just add a message handler to this
editor using `with_message_handler`. The message handler lets you react to inbound
messages from the GUI by passing a closure to it. We'll just respond with a `Pong`
by sending it via the editor channel.

*src/lib.rs*

```diff
    static EDITOR_DIR: Dir = include_dir!("$CARGO_MANIFEST_DIR/gui/dist");

    fn editor(&mut self, _async_executor: AsyncExecutor<Self>) -> Option<Box<dyn Editor>> {
        let sender = self.editor_channel.0.clone();

        ReactPlugEditor::new::<GuiMessage>(
            self.params.clone(),
            &EDITOR_DIR,
            self.editor_channel.clone(),
        )
        .with_developer_mode(true)
        .with_message_handler(move |message| {
+           if let GuiMessage::Ping = message {
+               sender.send(PluginMessage::Pong).unwrap();
+           }
        })
        .into()
    }
```

There are a lot more things you can do with the editor by chaining more methods, we
won't go into that here, though. Let's instead move on to the actual GUI.

## ğŸ–Œï¸ GUI

The GUI is written in React.

You can communicate with your plugin through the automatically generated
PluginContext, which you can use by calling `usePluginContext()`. It contains all
parameters, as well as methods for handling and sending messages.


<details>
  <summary>How does the PluginContext work?</summary>

Your React `App` component is wrapped by a `PluginProvider` component that provides
the necessary context. This provider internally abstracts over all plugin/GUI
communication. It's automatically generated and contains definitions for all your
parameters and messages. The macros we looked at before handle all of that for you.

```tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import PluginProvider from "./bindings/PluginProvider.tsx";

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <PluginProvider>
      <App/>
    </PluginProvider>
  </React.StrictMode>,
)
```

</details>

Let's first remove the boilerplate from before and do something else ourselves.
We'll start by just loading the plugin context.

```tsx
import {usePluginContext} from './bindings/PluginProvider';

function App() {
  const ctx = usePluginContext();

  return (
    <>
    </>
  )
}

export default App
```

### ğŸšï¸ Parameters

Let's display the current gain. We can do this by reading the name, value and unit
properties of `ctx.parameters.gain`.

```tsx
import {usePluginContext} from './bindings/PluginProvider';

function App() {
  const ctx = usePluginContext();
  const gain = ctx.parameters.gain;

  return (
    <div>{gain.name}: {gain.value}{gain.unit}</div>
  )
}

export default App
```

The `value` actually already has the proper formatting which we supplied in the
`rp_params!` definition.

> [!NOTE]
> This only works with `nih_plug`'s internal `v2s_*` formatters! If you supplied
> your own formatter, you'll have to handle formatting yourself in the GUI, too.

Let's add a slider for our "gain" parameter. We can use its raw value, normalization
function, and `setValue` function to display the gain value and update it when the
slider is tweaked.

```tsx
import {usePluginContext} from './bindings/PluginProvider';

function App() {
  const ctx = usePluginContext();
  const gain = ctx.parameters.gain;

  return (
    <div className="container">
      <div>{gain.name}: {gain.value}{gain.unit}</div>

      <input type="range" className="slider"
             min={0} max={1} step={0.001}
             value={gain.range.normalize(gain.rawValue)}
             onChange={e => {
               gain.setValue(gain.range.unnormalize(Number(e.target.value)))
             }}
      />

    </div>
  )
}

export default App
```

<details>
  <summary>Why is the min 0 and the max 1?</summary>

Because we want to normalize the gain value within its skewed range.

In the [plugin code](#-parameters), we set the gain parameter's range to be skewed.
So, in order to properly display its value, we'll need to show the normalized raw
value, which will always be between 0 and 1. When the slider's value changes, we do
update the parameter with the un-normalized value of the slider.
</details>

### ğŸ’¬ Messages

You can send messages to the plugin by calling `sendToPlugin()` on the
PluginContext. Let's send that `Ping` message we defined earlier.

```tsx
import {usePluginContext} from './bindings/PluginProvider';

function App() {
  const ctx = usePluginContext();

  return (
    <div className="container">
      <button onClick={() => ctx.sendToPlugin("Ping")}>Send Ping</button>
    </div>
  )
}

export default App
```

We set the plugin up to respond with a `Pong` every time it receives this message.
Let's see if it actually sends a `Pong`. In order to react to plugin messages, we
can add a listener for them. We'll do this inside a React `useEffect`, so that we
can unregister the listener, too.

```tsx
import {usePluginContext} from './bindings/PluginProvider';
import {useEffect, useState} from 'react';

function App() {
  const ctx = usePluginContext();
  const [pongCount, setPongCount] = useState(0);

  useEffect(() => {
    const listener = (message) => {
      if (message === "Pong")
        setPongCount(prevCount => prevCount + 1);
    };

    ctx.addMessageListener(listener);

    return () => ctx.removeMessageListener(listener);
  }, [ctx]);

  return (
    <div className="container">
      <button onClick={() => ctx.sendToPlugin("Ping")}>Send Ping</button>
      <div>Pong counter: {pongCount}</div>
    </div>
  )
}

export default App
```

Now, every time a `Pong` message is received, we'll increment the pong count.

## ğŸ¬ Fin~

And that's it! You've now seen how to use parameters, messages, and the
PluginContext in React-Plug!